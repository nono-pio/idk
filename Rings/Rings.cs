using System.Numerics;

namespace Rings;

/**
 * Common rings.
 *
 * @since 1.0
 */
public sealed class Rings {
    private Rings() {}

    public static RandomGenerator privateRandom = new Well44497b(DateTime.Now.Nanosecond);

    /**
     * Ring of integers (Z)
     */
    public static readonly Integers Z = Integers.ZZ;

    /**
     * Field of rationals (Q)
     */
    public static readonly Rationals<BigInteger> Q = new(Z);

    /**
     * Ring of rational functions over specified ring
     *
     * @param ring the ring that numerators and denominators belong to
     */
    public static Rationals<E> Frac<E>(Ring<E> ring) {
        return new(ring);
    }

    /**
     * Ring of integers modulo {@code modulus} (with modulus < 2^63)
     *
     * @param modulus the modulus
     */
    public static IntegersZp64 Zp64(long modulus) {return new IntegersZp64(modulus);}

    /**
     * Ring of integers modulo {@code modulus} (arbitrary large modulus)
     *
     * @param modulus the modulus (arbitrary large)
     */
    public static IntegersZp Zp(long modulus) {return new IntegersZp(modulus);}

    /**
     * Ring of integers modulo {@code modulus} (arbitrary large modulus)
     *
     * @param modulus the modulus (arbitrary large)
     */
    public static IntegersZp Zp(BigInteger modulus) {return new IntegersZp(modulus);}

    /**
     * Galois field with the cardinality {@code prime ^ exponent} (with prime < 2^63).
     *
     * @param prime    the integer prime modulus
     * @param exponent the exponent (degree of modulo polynomial)
     */
    public static FiniteField<UnivariatePolynomialZp64> GF(long prime, int exponent) {
        if (exponent <= 0)
            throw new ArgumentException("Exponent must be positive");
        // provide random generator with fixed seed to make the behavior predictable
        return new (IrreduciblePolynomials.randomIrreduciblePolynomial(prime, exponent, new Well19937c(0x77f3dfae)));
    }

    /**
     * Galois field with the cardinality {@code prime ^ exponent} for arbitrary large {@code prime}
     *
     * @param prime    the integer (arbitrary large) prime modulus
     * @param exponent the exponent (degree of modulo polynomial)
     */
    public static FiniteField<UnivariatePolynomial<BigInteger>> GF(BigInteger prime, int exponent) {
        if (exponent <= 0)
            throw new ArgumentException("Exponent must be positive");
        // provide random generator with fixed seed to make the behavior predictable
        return new (IrreduciblePolynomials.randomIrreduciblePolynomial(Zp(prime), exponent, new Well19937c(0x77f3dfae)));
    }

    /**
     * Galois field with the specified minimal polynomial. Note: there is no explicit check that minimal polynomial is
     * irreducible
     *
     * @param irreducible irreducible univariate polynomial
     */
    public static FiniteField<Poly> GF<Poly>(Poly irreducible) where Poly : IUnivariatePolynomial<Poly> {
        return new(irreducible);
    }

    /**
     * Algebraic number field generated by the specified minimal polynomial
     */
    public static AlgebraicNumberField<Poly> AlgebraicNumberField<Poly>(Poly minimalPoly) where Poly : IUnivariatePolynomial<Poly> {
        return new (minimalPoly);
    }

    /**
     * Gaussian numbers for a given ring (that is ring adjoined with imaginary unit)
     */
    public static  AlgebraicNumberField<UnivariatePolynomial<E>> GaussianNumbers<E>(Ring<E> ring) {
        return AlgebraicNumberField(UnivariatePolynomial.create(ring, ring.createArray(ring.getOne(), ring.getZero(), ring.getOne())));
    }

    /**
     * Field of Gaussian rationals (rational complex numbers).
     */
    public static AlgebraicNumberField<UnivariatePolynomial<Rational<BigInteger>>> GaussianRationals = GaussianNumbers(Q);

    /**
     * Ring of Gaussian integers (integer complex numbers).
     */
    public static AlgebraicNumberField<UnivariatePolynomial<BigInteger>> GaussianIntegers = GaussianNumbers(Z);

    /**
     * Quotient ring {@code baseRing/<modulus> }
     *
     * @deprecated Use either {@link #GF(IUnivariatePolynomial)} or {@link #AlgebraicNumberField(IUnivariatePolynomial)}
     */
    [Obsolete]
    public static SimpleFieldExtension<uPoly> UnivariateQuotientRing<uPoly>(uPoly modulus) where uPoly : IUnivariatePolynomial<uPoly> {
        return SimpleFieldExtension(modulus);
    }

    /**
     * Returns a simple field extension generated by given minimal polynomial
     */
    public static SimpleFieldExtension<uPoly> SimpleFieldExtension<uPoly>(uPoly minimalPolynomial) where uPoly : IUnivariatePolynomial<uPoly> {
        return minimalPolynomial.isOverFiniteField() ? GF(minimalPolynomial) : AlgebraicNumberField(minimalPolynomial);
    }

    /**
     * Multiple field extension generated by given algebraic elements represented by their minimal polynomials (not
     * tested that they are irreducible)
     */
    public static MultipleFieldExtension<Term, mPoly, sPoly> MultipleFieldExtension<Term, mPoly, sPoly>(params sPoly[] minimalPolynomials) 
                where Term : AMonomial<Term> 
                where mPoly : AMultivariatePolynomial<Term, mPoly> 
                where sPoly : IUnivariatePolynomial<sPoly> {
        return MultipleFieldExtension.mkMultipleExtension(minimalPolynomials);
    }

    /**
     * Splitting field of a given polynomial.
     */
    public static MultipleFieldExtension<Term, mPoly, sPoly> SplittingField<Term, mPoly, sPoly>(sPoly polynomial)
            where Term : AMonomial<Term>
            where mPoly : AMultivariatePolynomial<Term, mPoly>
            where sPoly : IUnivariatePolynomial<sPoly> {
        return MultipleFieldExtension.mkSplittingField(polynomial);
    }

    /**
     * Ring of univariate polynomials over specified coefficient ring
     *
     * @param coefficientRing the coefficient ring
     */
    public static UnivariateRing<UnivariatePolynomial<E>> UnivariateRing<E>(Ring<E> coefficientRing) {
        return new (UnivariatePolynomial.zero(coefficientRing));
    }

    /**
     * Ring of univariate polynomials with specified factory
     *
     * @param factory factory
     */
    public static UnivariateRing<Poly> UnivariateRing<Poly>(Poly factory) where Poly : IUnivariatePolynomial<Poly> {
        return new(factory);
    }

    /**
     * Ring of univariate polynomials over integers (Z[x])
     */
    public static readonly UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZ = UnivariateRing(Z);

    /**
     * Ring of univariate polynomials over rationals (Q[x])
     */
    public static readonly UnivariateRing<UnivariatePolynomial<Rational<BigInteger>>> UnivariateRingQ = UnivariateRing(Q);

    /**
     * Ring of univariate polynomials over Zp integers (Zp[x])
     *
     * @param modulus the modulus
     */
    public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(long modulus) {
        return new (UnivariatePolynomialZp64.zero(modulus));
    }

    /**
     * Ring of univariate polynomials over Zp integers (Zp[x])
     *
     * @param modulus the modulus
     */
    public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(IntegersZp64 modulus) {
        return new (UnivariatePolynomialZp64.zero(modulus));
    }

    /**
     * Ring of univariate polynomials over Zp integers (Zp[x]) with arbitrary large modulus
     *
     * @param modulus the modulus (arbitrary large)
     */
    public static UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZp(BigInteger modulus) {
        return UnivariateRing(Zp(modulus));
    }

    /**
     * Ring of multivariate polynomials with specified number of variables over specified coefficient ring
     *
     * @param nVariables      the number of variables
     * @param coefficientRing the coefficient ring
     * @param monomialOrder   the monomial order
     */
    public static  MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing, Comparator<DegreeVector> monomialOrder) {
        return new (MultivariatePolynomial.zero(nVariables, coefficientRing, monomialOrder));
    }

    /**
     * Ring of multivariate polynomials with specified number of variables over specified coefficient ring
     *
     * @param nVariables      the number of variables
     * @param coefficientRing the coefficient ring
     */
    public static MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing) {
        return MultivariateRing(nVariables, coefficientRing, MonomialOrder.DEFAULT);
    }

    /**
     * Ring of multivariate polynomials with specified factory
     *
     * @param factory factory
     */
    public static MultivariateRing<Poly> MultivariateRing<Term, Poly>(Poly factory) 
        where Term : AMonomial<Term>
        where Poly : AMultivariatePolynomial<Term, Poly> {
        return new (factory);
    }

    /**
     * Ring of multivariate polynomials over integers (Z[x1, x2, ...])
     *
     * @param nVariables the number of variables
     */
    public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZ(int nVariables) {
        return MultivariateRing(nVariables, Z);
    }

    /**
     * Ring of multivariate polynomials over rationals (Q[x1, x2, ...])
     *
     * @param nVariables the number of variables
     */
    public static MultivariateRing<MultivariatePolynomial<Rational<BigInteger>>> MultivariateRingQ(int nVariables) {
        return MultivariateRing(nVariables, Q);
    }

    /**
     * Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
     *
     * @param nVariables    the number of variables
     * @param modulus       the modulus
     * @param monomialOrder the monomial order
     */
    public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus, Comparator<DegreeVector> monomialOrder) {
        return new (MultivariatePolynomialZp64.zero(nVariables, Zp64(modulus), monomialOrder));
    }

    /**
     * Ring of multivariate polynomials over Zp machine integers (Zp[x1, x2, ...])
     *
     * @param nVariables the number of variables
     * @param modulus    the modulus
     */
    public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus) {
        return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
    }

    /**
     * Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
     *
     * @param nVariables    the number of variables
     * @param modulus       the modulus
     * @param monomialOrder monomial order
     */
    public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus, Comparator<DegreeVector> monomialOrder) {
        return new (MultivariatePolynomialZp64.zero(nVariables, modulus, monomialOrder));
    }

    /**
     * Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
     *
     * @param nVariables the number of variables
     * @param modulus    the modulus
     */
    public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus) {
        return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
    }

    /**
     * Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...]) with arbitrary large modulus
     *
     * @param nVariables the number of variables
     * @param modulus    the modulus (arbitrary large)
     */
    public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZp(int nVariables, BigInteger modulus) {
        return MultivariateRing(nVariables, Zp(modulus));
    }

    /**
     * Generic factory for polynomial ring
     */
    public static IPolynomialRing<Poly> PolynomialRing<Poly>(Poly factory) where Poly : IPolynomial<Poly> {
        if (factory is IUnivariatePolynomial)
            return (IPolynomialRing<Poly>) UnivariateRing((IUnivariatePolynomial) factory);
        else
            return (IPolynomialRing<Poly>) MultivariateRing((AMultivariatePolynomial) factory);
    }

    /**
     * Quotient ring {@code baseRing/<ideal> }
     */
    public static QuotientRing<Term, Poly> QuotientRing<Term, Poly>(MultivariateRing<Poly> baseRing, Ideal<Term, Poly> ideal)
        where Term : AMonomial<Term>
        where Poly : AMultivariatePolynomial<Term, Poly> {
        return new (baseRing, ideal);
    }
}
