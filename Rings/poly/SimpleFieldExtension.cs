using System.Diagnostics;
using System.Numerics;
using Rings.io;
using Rings.poly.univar;

namespace Rings.poly;


public abstract class SimpleFieldExtension<E> : ARing<E>, IPolynomialRing<E> where E : IUnivariatePolynomial<E>
{
    private static readonly long serialVersionUID = 1L;

    
    readonly E minimalPoly;

    
    readonly E Factory;

    
    readonly UnivariateDivision.InverseModMonomial<E> inverseMod;

    
    readonly BigInteger Cardinality;

    /**
     * Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
     * minimal polynomial.
     *
     * <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
     * IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
     *
     * @param minimalPoly the minimal polynomial
     */
    protected SimpleFieldExtension(E minimalPoly)
    {
        minimalPoly = minimalPoly.monic();
        if (minimalPoly == null)
            throw new ArgumentException("Minimal polynomial must be monic");
        this.minimalPoly = minimalPoly;
        this.Factory = minimalPoly.clone();
        this.inverseMod = UnivariateDivision.fastDivisionPreConditioning(minimalPoly);
        this.Cardinality = minimalPoly.coefficientRingCardinality() == null
            ? null
            : BigIntegerUtil.pow(minimalPoly.coefficientRingCardinality(), minimalPoly.degree());
    }

    
    public bool isInTheBaseField(E element)
    {
        return element.isConstant();
    }

    
    public E generator()
    {
        return minimalPoly.createMonomial(1);
    }

    
    public int degree()
    {
        return minimalPoly.degree();
    }

    /**
     * Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
     * viewed as quotient field {@code F[x]/<p(x)>})
     */
    public E getMinimalPolynomial()
    {
        return minimalPoly.clone();
    }

    
    public E getMinimalPolynomialRef()
    {
        return minimalPoly;
    }

    
    public E norm(E element)
    {
        return UnivariateResultants.ResultantAsPoly(minimalPoly, element);
    }

    /**
     * Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
     * element}
     */
    public E conjugatesProduct(E element)
    {
        return divideExact(norm(element), element);
    }

    
    public E trace(E element)
    {
        E minimalPoly = minimalPolynomial(element);
        return negate(divideExact(minimalPoly.getAsPoly(minimalPoly.degree() - 1), minimalPoly.lcAsPoly()));
    }

    
    public E normOfPolynomial(UnivariatePolynomial<E> poly)
    {
        if (!poly.ring.Equals(this))
            throw new ArgumentException();
        if (minimalPoly is UnivariatePolynomial)
            return (E)normOfPolynomialE((SimpleFieldExtension)this, (UnivariatePolynomial)poly);
        if (minimalPoly is UnivariatePolynomialZp64)
            return (E)normOfPolynomialZp64((SimpleFieldExtension)this, (UnivariatePolynomial)poly);
        throw new Exception();
    }

    private static UnivariatePolynomial<E>
        normOfPolynomialE<E>(SimpleFieldExtension<UnivariatePolynomial<E>> ring,
            UnivariatePolynomial<UnivariatePolynomial<E>> poly)
    {
        return MultivariateResultants.Resultant(
            ring.minimalPoly.asMultivariate(MonomialOrder.DEFAULT).setNVariables(2), // to bivariate
            MultivariatePolynomial.asNormalMultivariate(poly.asMultivariate(), 0),
            0).asUnivariate();
    }

    private static UnivariatePolynomialZp64
        normOfPolynomialZp64(SimpleFieldExtension<UnivariatePolynomialZp64> ring,
            UnivariatePolynomial<UnivariatePolynomialZp64> poly)
    {
        return MultivariateResultants.Resultant(
            ring.minimalPoly.asMultivariate(MonomialOrder.DEFAULT).setNVariables(2),
            MultivariatePolynomialZp64.asNormalMultivariate(poly.asMultivariate(), 0),
            0).asUnivariate();
    }

    
    public <MPoly extends AMultivariatePolynomial>

    MPoly normOfPolynomial(MultivariatePolynomial<E> poly)
    {
        if (!poly.ring.equals(this))
            throw new IllegalArgumentException();
        if (minimalPoly instanceof UnivariatePolynomial)
        return (MPoly)normOfPolynomialE((SimpleFieldExtension)this, (MultivariatePolynomial)poly);
        if (minimalPoly instanceof UnivariatePolynomialZp64)
        return (MPoly)normOfPolynomialZp64((SimpleFieldExtension)this, (MultivariatePolynomial)poly);
        throw new RuntimeException();
    }

    private static MultivariatePolynomial<E>
        normOfPolynomialE<E>(SimpleFieldExtension<UnivariatePolynomial<E>> ring,
            MultivariatePolynomial<UnivariatePolynomial<E>> poly)
    {
        return MultivariateResultants.Resultant(
            ring.minimalPoly.asMultivariate(MonomialOrder.DEFAULT).setNVariables(poly.nVariables + 1),
            MultivariatePolynomial.asNormalMultivariate(poly, 0),
            0).dropVariable(0);
    }

    private static MultivariatePolynomialZp64
        normOfPolynomialZp64(SimpleFieldExtension<UnivariatePolynomialZp64> ring,
            MultivariatePolynomial<UnivariatePolynomialZp64> poly)
    {
        return MultivariateResultants.Resultant(
            ring.minimalPoly.asMultivariate(MonomialOrder.DEFAULT).setNVariables(poly.nVariables + 1),
            MultivariatePolynomialZp64.asNormalMultivariate(poly, 0),
            0).dropVariable(0);
    }

    
    public E minimalPolynomial(E element)
    {
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        UnivariatePolynomial<E> es = UnivariatePolynomial<E>.create(this, [negate(element), getOne()]);
        return UnivariateSquareFreeFactorization.SquareFreePart(normOfPolynomial(es));
    }

    
    public <Term extends AMonomial<Term>, mPoly extends AMultivariatePolynomial<Term, mPoly>>

    MultipleFieldExtension<Term, mPoly, E> asMultipleExtension()
    {
        return MultipleFieldExtension.mkMultipleExtension(this);
    }

    public int nVariables()
    {
        return 1;
    }

    public E factory()
    {
        return Factory;
    }

    public bool isEuclideanRing()
    {
        return minimalPoly.isOverField();
    }

    public BigInteger cardinality()
    {
        return Cardinality;
    }

    public BigInteger characteristic()
    {
        return minimalPoly.coefficientRingCharacteristic();
    }

    
    protected bool shouldReduceFast(int dividendDegree)
    {
        int mDeg = minimalPoly.degree();
        if (dividendDegree < mDeg)
            return false;
        if (isFiniteField())
        {
            if (mDeg < 8)
                return false;
            int defect = dividendDegree / mDeg;
            if (mDeg <= 20)
                return defect <= 16;
            else
                return defect <= 30;
        }
        else
            return false;
    }

    public override E add(E a, E b)
    {
        return shouldReduceFast(Math.Max(a.degree(), b.degree()))
            ? polyAddMod(a, b, minimalPoly, inverseMod, true)
            : polyAddMod(a, b, minimalPoly, true);
    }

    public override E subtract(E a, E b)
    {
        return shouldReduceFast(Math.Max(a.degree(), b.degree()))
            ? polySubtractMod(a, b, minimalPoly, inverseMod, true)
            : polySubtractMod(a, b, minimalPoly, true);
    }

    public override E multiply(E a, E b)
    {
        return shouldReduceFast(a.degree() + b.degree())
            ? polyMultiplyMod(a, b, minimalPoly, inverseMod, true)
            : polyMultiplyMod(a, b, minimalPoly, true);
    }

    public override E negate(E element)
    {
        return shouldReduceFast(element.degree())
            ? polyNegateMod(element, minimalPoly, inverseMod, true)
            : polyNegateMod(element, minimalPoly, true);
    }

    public E addMutable(E a, E b)
    {
        return shouldReduceFast(Math.Max(a.degree(), b.degree()))
            ? polyAddMod(a, b, minimalPoly, inverseMod, false)
            : polyAddMod(a, b, minimalPoly, false);
    }

    public E subtractMutable(E a, E b)
    {
        return shouldReduceFast(Math.Max(a.degree(), b.degree()))
            ? polySubtractMod(a, b, minimalPoly, inverseMod, false)
            : polySubtractMod(a, b, minimalPoly, false);
    }

    public E multiplyMutable(E a, E b)
    {
        return shouldReduceFast(a.degree() + b.degree())
            ? polyMultiplyMod(a, b, minimalPoly, inverseMod, false)
            : polyMultiplyMod(a, b, minimalPoly, false);
    }

    public E negateMutable(E element)
    {
        return shouldReduceFast(element.degree())
            ? polyNegateMod(element, minimalPoly, inverseMod, false)
            : polyNegateMod(element, minimalPoly, false);
    }

    public override E reciprocal(E element)
    {
        if (element.isZero())
            throw new ArithmeticException("divide by zero");
        if (isOne(element))
            return element;
        if (isMinusOne(element))
            return element;

        E[] xgcd = UnivariateGCD.PolynomialFirstBezoutCoefficient(element, minimalPoly);
        Debug.Assert(xgcd[0].isConstant());
        return xgcd[1].divideByLC(xgcd[0]);
    }

    public FactorDecomposition<E> factor(E element)
    {
        return FactorDecomposition<E>.Unit(this, element);
    }

    public override E getZero()
    {
        return minimalPoly.createZero();
    }

    public override E getOne()
    {
        return minimalPoly.createOne();
    }

    public override bool isZero(E element)
    {
        return element.isZero();
    }

    public override bool isOne(E element)
    {
        return element.isOne();
    }

    public override E valueOf(long val)
    {
        return getOne().multiply(val);
    }

    public override E valueOfBigInteger(BigInteger val)
    {
        return getOne().multiplyByBigInteger(val);
    }

    public override E valueOf(E val)
    {
        return shouldReduceFast(val.degree())
            ? polyMod(val.setCoefficientRingFrom(Factory), minimalPoly, inverseMod, false)
            : polyMod(val.setCoefficientRingFrom(Factory), minimalPoly, false);
    }

    public override E copy(E element)
    {
        return element.clone();
    }


    public override int compare(E o1, E o2)
    {
        return o1.compareTo(o2);
    }

    public E randomElement(RandomGenerator rnd)
    {
        E r = RandomUnivariatePolynomials.randomPoly(minimalPoly, rnd.nextInt(minimalPoly.degree()), rnd);
        if (r.isOverFiniteField())
        {
            if (r is UnivariatePolynomial)
                ((UnivariatePolynomial)r).multiply(((UnivariatePolynomial)r).ring.randomElement(rnd));
            else
                r.multiply(rnd.nextLong());
        }

        return r;
    }

    public E variable(int variable)
    {
        if (variable != 0)
            throw new ArgumentException();
        return valueOf(minimalPoly.createMonomial(1));
    }

    public E parse(String str)
    {
        return valueOf(Factory.parsePoly(str));
    }

    public bool equals(Object o)
    {
        if (this == o) return true;
        if (o == null || GetType() != o.GetType()) return false;

        SimpleFieldExtension < ?> that = (SimpleFieldExtension < ?>) o;
        return minimalPoly.Equals(that.minimalPoly);
    }

    public int hashCode()
    {
        return minimalPoly.GetHashCode();
    }

    public String toString(IStringifier<E> stringifier)
    {
        String cfrStr = Factory.coefficientRingToString(stringifier);
        String varStr = stringifier.getBinding(Factory.createMonomial(1), IStringifier<E>.defaultVar());
        String irrStr = minimalPoly.toString(stringifier);
        return "(" + cfrStr + ")[" + varStr + "]/<" + irrStr + ">";
    }

    public String toString(params String[] variables)
    {
        return toString(IStringifier<E>.mkPolyStringifier(factory, variables));
    }

    public String toString()
    {
        return toString(IStringifier<E>.defaultVars(1));
    }
}