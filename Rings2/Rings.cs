using Cc.Redberry.Rings.Bigint;
using Cc.Redberry.Rings;
using Cc.Redberry.Rings.Poly;
using Cc.Redberry.Rings.Poly.Univar;
using Org.Apache.Commons.Math3.Random;
using Java.Util;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;

namespace Cc.Redberry.Rings
{
    /// <summary>
    /// Common rings.
    /// </summary>
    /// <remarks>@since1.0</remarks>
    public sealed class Rings
    {
        private Rings()
        {
        }

        public static RandomGenerator privateRandom = new Well44497b(System.NanoTime());
        /// <summary>
        /// Ring of integers (Z)
        /// </summary>
        public static readonly Integers Z = Integers.Integers;
        /// <summary>
        /// Field of rationals (Q)
        /// </summary>
        public static readonly Rationals<BigInteger> Q = new Rationals(Z);
        /// <summary>
        /// Ring of rational functions over specified ring
        /// </summary>
        /// <param name="ring">the ring that numerators and denominators belong to</param>
        public static Rationals<E> Frac<E>(Ring<E> ring)
        {
            return new Rationals(ring);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (with modulus < 2^63)
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static IntegersZp64 Zp64(long modulus)
        {
            return new IntegersZp64(modulus);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (arbitrary large modulus)
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static IntegersZp Zp(long modulus)
        {
            return new IntegersZp(modulus);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (arbitrary large modulus)
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static IntegersZp Zp(BigInteger modulus)
        {
            return new IntegersZp(modulus);
        }

        /// <summary>
        /// Galois field with the cardinality {@code prime ^ exponent} (with prime < 2^63).
        /// </summary>
        /// <param name="prime">the integer prime modulus</param>
        /// <param name="exponent">the exponent (degree of modulo polynomial)</param>
        public static FiniteField<UnivariatePolynomialZp64> GF(long prime, int exponent)
        {
            if (exponent <= 0)
                throw new ArgumentException("Exponent must be positive");

            // provide random generator with fixed seed to make the behavior predictable
            return new FiniteField(IrreduciblePolynomials.RandomIrreduciblePolynomial(prime, exponent, new Well19937c(0x77f3dfae)));
        }

        /// <summary>
        /// Galois field with the cardinality {@code prime ^ exponent} for arbitrary large {@code prime}
        /// </summary>
        /// <param name="prime">the integer (arbitrary large) prime modulus</param>
        /// <param name="exponent">the exponent (degree of modulo polynomial)</param>
        public static FiniteField<UnivariatePolynomial<BigInteger>> GF(BigInteger prime, int exponent)
        {
            if (exponent <= 0)
                throw new ArgumentException("Exponent must be positive");

            // provide random generator with fixed seed to make the behavior predictable
            return new FiniteField(IrreduciblePolynomials.RandomIrreduciblePolynomial(Zp(prime), exponent, new Well19937c(0x77f3dfae)));
        }

        /// <summary>
        /// Galois field with the specified minimal polynomial. Note: there is no explicit check that minimal polynomial is
        /// irreducible
        /// </summary>
        /// <param name="irreducible">irreducible univariate polynomial</param>
        public static FiniteField<Poly> GF<Poly extends IUnivariatePolynomial<Poly>>(Poly irreducible)
        {
            return new FiniteField(irreducible);
        }

        /// <summary>
        /// Algebraic number field generated by the specified minimal polynomial
        /// </summary>
        public static AlgebraicNumberField<Poly> AlgebraicNumberField<Poly extends IUnivariatePolynomial<Poly>>(Poly minimalPoly)
        {
            return new AlgebraicNumberField(minimalPoly);
        }

        /// <summary>
        /// Gaussian numbers for a given ring (that is ring adjoined with imaginary unit)
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<E>> GaussianNumbers<E>(Ring<E> ring)
        {
            return AlgebraicNumberField(UnivariatePolynomial.Create(ring, ring.CreateArray(ring.GetOne(), ring.GetZero(), ring.GetOne())));
        }

        /// <summary>
        /// Field of Gaussian rationals (rational complex numbers).
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<Rational<BigInteger>>> GaussianRationals = GaussianNumbers(Q);
        /// <summary>
        /// Ring of Gaussian integers (integer complex numbers).
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<BigInteger>> GaussianIntegers = GaussianNumbers(Z);
        /// <summary>
        /// Quotient ring {@code baseRing/<modulus> }
        /// </summary>
        /// <remarks>@deprecatedUse either {@link #GF(IUnivariatePolynomial)} or {@link #AlgebraicNumberField(IUnivariatePolynomial)}</remarks>
        public static SimpleFieldExtension<uPoly> UnivariateQuotientRing<uPoly extends IUnivariatePolynomial<uPoly>>(uPoly modulus)
        {
            return SimpleFieldExtension(modulus);
        }

        /// <summary>
        /// Returns a simple field extension generated by given minimal polynomial
        /// </summary>
        public static SimpleFieldExtension<uPoly> SimpleFieldExtension<uPoly extends IUnivariatePolynomial<uPoly>>(uPoly minimalPolynomial)
        {
            return minimalPolynomial.IsOverFiniteField() ? GF(minimalPolynomial) : AlgebraicNumberField(minimalPolynomial);
        }

        /// <summary>
        /// Multiple field extension generated by given algebraic elements represented by their minimal polynomials (not
        /// tested that they are irreducible)
        /// </summary>
        public static MultipleFieldExtension<Term, mPoly, sPoly> MultipleFieldExtension<Term extends AMonomial<Term>, mPoly extends AMultivariatePolynomial<Term, mPoly>, sPoly extends IUnivariatePolynomial<sPoly>>(params sPoly[] minimalPolynomials)
        {
            return MultipleFieldExtension.MkMultipleExtension(minimalPolynomials);
        }

        /// <summary>
        /// Splitting field of a given polynomial.
        /// </summary>
        public static MultipleFieldExtension<Term, mPoly, sPoly> SplittingField<Term extends AMonomial<Term>, mPoly extends AMultivariatePolynomial<Term, mPoly>, sPoly extends IUnivariatePolynomial<sPoly>>(sPoly polynomial)
        {
            return MultipleFieldExtension.MkSplittingField(polynomial);
        }

        /// <summary>
        /// Ring of univariate polynomials over specified coefficient ring
        /// </summary>
        /// <param name="coefficientRing">the coefficient ring</param>
        public static UnivariateRing<UnivariatePolynomial<E>> UnivariateRing<E>(Ring<E> coefficientRing)
        {
            return new UnivariateRing(UnivariatePolynomial.Zero(coefficientRing));
        }

        /// <summary>
        /// Ring of univariate polynomials with specified factory
        /// </summary>
        /// <param name="factory">factory</param>
        public static UnivariateRing<Poly> UnivariateRing<Poly extends IUnivariatePolynomial<Poly>>(Poly factory)
        {
            return new UnivariateRing(factory);
        }

        /// <summary>
        /// Ring of univariate polynomials over integers (Z[x])
        /// </summary>
        public static readonly UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZ = UnivariateRing(Z);
        /// <summary>
        /// Ring of univariate polynomials over rationals (Q[x])
        /// </summary>
        public static readonly UnivariateRing<UnivariatePolynomial<Rational<BigInteger>>> UnivariateRingQ = UnivariateRing(Q);
        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x])
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(long modulus)
        {
            return new UnivariateRing(UnivariatePolynomialZp64.Zero(modulus));
        }

        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x])
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(IntegersZp64 modulus)
        {
            return new UnivariateRing(UnivariatePolynomialZp64.Zero(modulus));
        }

        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x]) with arbitrary large modulus
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZp(BigInteger modulus)
        {
            return UnivariateRing(Zp(modulus));
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified number of variables over specified coefficient ring
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="coefficientRing">the coefficient ring</param>
        /// <param name="monomialOrder">the monomial order</param>
        public static MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing, Comparator<DegreeVector> monomialOrder)
        {
            return new MultivariateRing(MultivariatePolynomial.Zero(nVariables, coefficientRing, monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified number of variables over specified coefficient ring
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="coefficientRing">the coefficient ring</param>
        public static MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing)
        {
            return MultivariateRing(nVariables, coefficientRing, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified factory
        /// </summary>
        /// <param name="factory">factory</param>
        public static MultivariateRing<Poly> MultivariateRing<Term extends AMonomial<Term>, Poly extends AMultivariatePolynomial<Term, Poly>>(Poly factory)
        {
            return new MultivariateRing(factory);
        }

        /// <summary>
        /// Ring of multivariate polynomials over integers (Z[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZ(int nVariables)
        {
            return MultivariateRing(nVariables, Z);
        }

        /// <summary>
        /// Ring of multivariate polynomials over rationals (Q[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        public static MultivariateRing<MultivariatePolynomial<Rational<BigInteger>>> MultivariateRingQ(int nVariables)
        {
            return MultivariateRing(nVariables, Q);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        /// <param name="monomialOrder">the monomial order</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus, Comparator<DegreeVector> monomialOrder)
        {
            return new MultivariateRing(MultivariatePolynomialZp64.Zero(nVariables, Zp64(modulus), monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp machine integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus)
        {
            return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        /// <param name="monomialOrder">monomial order</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus, Comparator<DegreeVector> monomialOrder)
        {
            return new MultivariateRing(MultivariatePolynomialZp64.Zero(nVariables, modulus, monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus)
        {
            return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...]) with arbitrary large modulus
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZp(int nVariables, BigInteger modulus)
        {
            return MultivariateRing(nVariables, Zp(modulus));
        }

        /// <summary>
        /// Generic factory for polynomial ring
        /// </summary>
        public static IPolynomialRing<Poly> PolynomialRing<Poly extends IPolynomial<Poly>>(Poly factory)
        {
            if (factory is IUnivariatePolynomial)
                return (IPolynomialRing<Poly>)UnivariateRing((IUnivariatePolynomial)factory);
            else
                return (IPolynomialRing<Poly>)MultivariateRing((AMultivariatePolynomial)factory);
        }

        /// <summary>
        /// Quotient ring {@code baseRing/<ideal> }
        /// </summary>
        public static QuotientRing<Term, Poly> QuotientRing<Term extends AMonomial<Term>, Poly extends AMultivariatePolynomial<Term, Poly>>(MultivariateRing<Poly> baseRing, Ideal<Term, Poly> ideal)
        {
            return new QuotientRing(baseRing, ideal);
        }
    }
}