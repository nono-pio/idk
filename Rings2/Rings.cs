using System.Numerics;
using Cc.Redberry.Rings.Poly;
using Cc.Redberry.Rings.Poly.Multivar;
using Cc.Redberry.Rings.Poly.Univar;

namespace Cc.Redberry.Rings
{
    /// <summary>
    /// Common rings.
    /// </summary>
    /// <remarks>@since1.0</remarks>
    public sealed class Rings
    {
        private Rings()
        {
        }

        public static Random privateRandom = new Random(DateTime.Now.Nanosecond);
        /// <summary>
        /// Ring of integers (Z)
        /// </summary>
        public static readonly Integers Z = Integers.Z;
        /// <summary>
        /// Field of rationals (Q)
        /// </summary>
        public static readonly Rationals<BigInteger> Q = new Rationals<BigInteger>(Z);
        /// <summary>
        /// Ring of rational functions over specified ring
        /// </summary>
        /// <param name="ring">the ring that numerators and denominators belong to</param>
        public static Rationals<E> Frac<E>(Ring<E> ring)
        {
            return new Rationals<E>(ring);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (with modulus smaller than 2^63)
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static IntegersZp64 Zp64(long modulus)
        {
            return new IntegersZp64(modulus);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (arbitrary large modulus)
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static IntegersZp Zp(long modulus)
        {
            return new IntegersZp(modulus);
        }

        /// <summary>
        /// Ring of integers modulo {@code modulus} (arbitrary large modulus)
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static IntegersZp Zp(BigInteger modulus)
        {
            return new IntegersZp(modulus);
        }

        /// <summary>
        /// Galois field with the cardinality {@code prime ^ exponent} (with prime smaller than 2^63).
        /// </summary>
        /// <param name="prime">the integer prime modulus</param>
        /// <param name="exponent">the exponent (degree of modulo polynomial)</param>
        public static FiniteField<UnivariatePolynomialZp64> GF(long prime, int exponent)
        {
            if (exponent <= 0)
                throw new ArgumentException("Exponent must be positive");

            // provide random generator with fixed seed to make the behavior predictable
            return new FiniteField<UnivariatePolynomialZp64>(IrreduciblePolynomials.RandomIrreduciblePolynomial(prime, exponent, new Random(0x77f3dfae)));
        }

        /// <summary>
        /// Galois field with the cardinality {@code prime ^ exponent} for arbitrary large {@code prime}
        /// </summary>
        /// <param name="prime">the integer (arbitrary large) prime modulus</param>
        /// <param name="exponent">the exponent (degree of modulo polynomial)</param>
        public static FiniteField<UnivariatePolynomial<BigInteger>> GF(BigInteger prime, int exponent)
        {
            if (exponent <= 0)
                throw new ArgumentException("Exponent must be positive");

            // provide random generator with fixed seed to make the behavior predictable
            return new FiniteField<UnivariatePolynomial<BigInteger>>(IrreduciblePolynomials.RandomIrreduciblePolynomial(Zp(prime), exponent, new Random(0x77f3dfae)));
        }

        /// <summary>
        /// Galois field with the specified minimal polynomial. Note: there is no explicit check that minimal polynomial is
        /// irreducible
        /// </summary>
        /// <param name="irreducible">irreducible univariate polynomial</param>
        public static FiniteField<Poly> GF<Poly>(Poly irreducible) where Poly : IUnivariatePolynomial<Poly>
        {
            return new FiniteField<Poly>(irreducible);
        }

        /// <summary>
        /// Algebraic number field generated by the specified minimal polynomial
        /// </summary>
        public static AlgebraicNumberField<Poly> AlgebraicNumberField<Poly>(Poly minimalPoly) where Poly : IUnivariatePolynomial<Poly>
        {
            return new AlgebraicNumberField<Poly>(minimalPoly);
        }

        /// <summary>
        /// Gaussian numbers for a given ring (that is ring adjoined with imaginary unit)
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<E>> GaussianNumbers<E>(Ring<E> ring)
        {
            return AlgebraicNumberField(UnivariatePolynomial<E>.Create(ring, ring.CreateArray(ring.GetOne(), ring.GetZero(), ring.GetOne())));
        }

        /// <summary>
        /// Field of Gaussian rationals (rational complex numbers).
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<Rational<BigInteger>>> GaussianRationals = GaussianNumbers(Q);
        /// <summary>
        /// Ring of Gaussian integers (integer complex numbers).
        /// </summary>
        public static AlgebraicNumberField<UnivariatePolynomial<BigInteger>> GaussianIntegers = GaussianNumbers(Z);
        /// <summary>
        /// Quotient ring {@code baseRing/modulus }
        /// </summary>
        /// <remarks>@deprecatedUse either {@link #GF(IUnivariatePolynomial)} or {@link #AlgebraicNumberField(IUnivariatePolynomial)}</remarks>
        public static SimpleFieldExtension<uPoly> UnivariateQuotientRing<uPoly>(uPoly modulus) where uPoly : IUnivariatePolynomial<uPoly>
        {
            return SimpleFieldExtension(modulus);
        }

        /// <summary>
        /// Returns a simple field extension generated by given minimal polynomial
        /// </summary>
        public static SimpleFieldExtension<uPoly> SimpleFieldExtension<uPoly>(uPoly minimalPolynomial) where uPoly : IUnivariatePolynomial<uPoly>
        {
            return minimalPolynomial.IsOverFiniteField() ? GF(minimalPolynomial) : AlgebraicNumberField(minimalPolynomial);
        }

        /// <summary>
        /// Multiple field extension generated by given algebraic elements represented by their minimal polynomials (not
        /// tested that they are irreducible)
        /// </summary>
        public static MultipleFieldExtension<Term, mPoly, sPoly> MultipleFieldExtension<Term, mPoly, sPoly>(params sPoly[] minimalPolynomials) where Term : AMonomial<Term> where mPoly : AMultivariatePolynomial<Term, mPoly> where sPoly : IUnivariatePolynomial<sPoly>
        {
            return Poly.MultipleFieldExtension<Term, mPoly, sPoly>.MkMultipleExtension(minimalPolynomials);
        }

        /// <summary>
        /// Splitting field of a given polynomial.
        /// </summary>
        public static MultipleFieldExtension<Term, mPoly, sPoly> SplittingField<Term, mPoly, sPoly>(sPoly polynomial) where Term : AMonomial<Term> where mPoly : AMultivariatePolynomial<Term, mPoly> where sPoly : IUnivariatePolynomial<sPoly>
        {
            return Poly.MultipleFieldExtension<Term, mPoly, sPoly>.MkSplittingField(polynomial);
        }

        /// <summary>
        /// Ring of univariate polynomials over specified coefficient ring
        /// </summary>
        /// <param name="coefficientRing">the coefficient ring</param>
        public static UnivariateRing<UnivariatePolynomial<E>> UnivariateRing<E>(Ring<E> coefficientRing)
        {
            return new UnivariateRing<UnivariatePolynomial<E>>(UnivariatePolynomial<E>.Zero(coefficientRing));
        }

        /// <summary>
        /// Ring of univariate polynomials with specified factory
        /// </summary>
        /// <param name="factory">factory</param>
        public static UnivariateRing<Poly> UnivariateRing<Poly>(Poly factory) where Poly : IUnivariatePolynomial<Poly>
        {
            return new UnivariateRing<Poly>(factory);
        }

        /// <summary>
        /// Ring of univariate polynomials over integers (Z[x])
        /// </summary>
        public static readonly UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZ = UnivariateRing(Z);
        /// <summary>
        /// Ring of univariate polynomials over rationals (Q[x])
        /// </summary>
        public static readonly UnivariateRing<UnivariatePolynomial<Rational<BigInteger>>> UnivariateRingQ = UnivariateRing(Q);
        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x])
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(long modulus)
        {
            return new UnivariateRing<UnivariatePolynomialZp64>(UnivariatePolynomialZp64.Zero(modulus));
        }

        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x])
        /// </summary>
        /// <param name="modulus">the modulus</param>
        public static UnivariateRing<UnivariatePolynomialZp64> UnivariateRingZp64(IntegersZp64 modulus)
        {
            return new UnivariateRing<UnivariatePolynomialZp64>(UnivariatePolynomialZp64.Zero(modulus));
        }

        /// <summary>
        /// Ring of univariate polynomials over Zp integers (Zp[x]) with arbitrary large modulus
        /// </summary>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static UnivariateRing<UnivariatePolynomial<BigInteger>> UnivariateRingZp(BigInteger modulus)
        {
            return UnivariateRing(Zp(modulus));
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified number of variables over specified coefficient ring
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="coefficientRing">the coefficient ring</param>
        /// <param name="monomialOrder">the monomial order</param>
        public static MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing, IComparer<DegreeVector> monomialOrder)
        {
            return new MultivariateRing<MultivariatePolynomial<E>>(MultivariatePolynomial<E>.Zero(nVariables, coefficientRing, monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified number of variables over specified coefficient ring
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="coefficientRing">the coefficient ring</param>
        public static MultivariateRing<MultivariatePolynomial<E>> MultivariateRing<E>(int nVariables, Ring<E> coefficientRing)
        {
            return MultivariateRing(nVariables, coefficientRing, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials with specified factory
        /// </summary>
        /// <param name="factory">factory</param>
        public static MultivariateRing<Poly> MultivariateRing<Term, Poly>(Poly factory) where Term : AMonomial<Term> where Poly : AMultivariatePolynomial<Term, Poly>
        {
            return new MultivariateRing<Poly>(factory);
        }

        /// <summary>
        /// Ring of multivariate polynomials over integers (Z[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZ(int nVariables)
        {
            return MultivariateRing(nVariables, Z);
        }

        /// <summary>
        /// Ring of multivariate polynomials over rationals (Q[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        public static MultivariateRing<MultivariatePolynomial<Rational<BigInteger>>> MultivariateRingQ(int nVariables)
        {
            return MultivariateRing(nVariables, Q);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        /// <param name="monomialOrder">the monomial order</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus, IComparer<DegreeVector> monomialOrder)
        {
            return new MultivariateRing<MultivariatePolynomialZp64>(MultivariatePolynomialZp64.Zero(nVariables, Zp64(modulus), monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp machine integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, long modulus)
        {
            return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        /// <param name="monomialOrder">monomial order</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus, IComparer<DegreeVector> monomialOrder)
        {
            return new MultivariateRing<MultivariatePolynomialZp64>(MultivariatePolynomialZp64.Zero(nVariables, modulus, monomialOrder));
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...])
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus</param>
        public static MultivariateRing<MultivariatePolynomialZp64> MultivariateRingZp64(int nVariables, IntegersZp64 modulus)
        {
            return MultivariateRingZp64(nVariables, modulus, MonomialOrder.DEFAULT);
        }

        /// <summary>
        /// Ring of multivariate polynomials over Zp integers (Zp[x1, x2, ...]) with arbitrary large modulus
        /// </summary>
        /// <param name="nVariables">the number of variables</param>
        /// <param name="modulus">the modulus (arbitrary large)</param>
        public static MultivariateRing<MultivariatePolynomial<BigInteger>> MultivariateRingZp(int nVariables, BigInteger modulus)
        {
            return MultivariateRing(nVariables, Zp(modulus));
        }

        /// <summary>
        /// Generic factory for polynomial ring
        /// </summary>
        public static IPolynomialRing<Poly> PolynomialRing<Poly>(Poly factory) where Poly : IUnivariatePolynomial<Poly>
            => UnivariateRing(factory);
        /// <summary>
        /// Generic factory for polynomial ring
        /// </summary>
        public static IPolynomialRing<Poly> PolynomialRing<Term, Poly>(Poly factory) where Term : AMonomial<Term> where Poly : AMultivariatePolynomial<Term, Poly>
            => MultivariateRing<Term, Poly>(factory);

        /// <summary>
        /// Quotient ring {@code baseRing/ideal }
        /// </summary>
        public static QuotientRing<Term, Poly> QuotientRing<Term, Poly>(MultivariateRing<Poly> baseRing, Ideal<Term, Poly> ideal) where Term : AMonomial<Term> where Poly : AMultivariatePolynomial<Term, Poly>
        {
            return new QuotientRing<Term, Poly>(baseRing, ideal);
        }
    }
}