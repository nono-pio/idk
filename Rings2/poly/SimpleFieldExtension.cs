using System.Numerics;
using Cc.Redberry.Rings;
using Cc.Redberry.Rings.Bigint;
using Cc.Redberry.Rings.Io;
using Cc.Redberry.Rings.Poly;
using Cc.Redberry.Rings.Poly.Multivar;
using Cc.Redberry.Rings.Poly.Univar;


namespace Cc.Redberry.Rings.Poly
{
    /// <summary>
    /// A simple field extension {@code F(α)} represented as a univariate quotient ring {@code F[x]/<m(x)>} where {@code
    /// m(x)} is the minimal polynomial of {@code α}. Elements of extension field are represented as univariate polynomials
    /// in {@code α}. To create simple field extensions one should use either {@link FiniteField} for extensions of finite
    /// fields or {@link AlgebraicNumberField} for extensions of rationals. See {@link MultipleFieldExtension} for
    /// implementation of multiple extensions.
    /// </summary>
    /// <remarks>
    /// @seeFiniteField
    /// @seeAlgebraicNumberField
    /// @seecc.redberry.rings.Rings#SimpleFieldExtension(IUnivariatePolynomial)
    /// @seeMultipleFieldExtension
    /// @since2.5
    /// </remarks>
    public abstract class SimpleFieldExtension<E> : ARing<E>, IPolynomialRing<E> where E : IPolynomial<E>
    {
        private static readonly long serialVersionUID = 1;
        /// <summary>
        /// Minimal polynomial
        /// </summary>
        readonly E minimalPoly;
        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        readonly E factory;
        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        readonly UnivariateDivision.InverseModMonomial<E> inverseMod;
        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        readonly BigInteger cardinality;
        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        protected SimpleFieldExtension(E minimalPoly)
        {
            minimalPoly = minimalPoly.Monic();
            if (minimalPoly == null)
                throw new ArgumentException("Minimal polynomial must be monic");
            this.minimalPoly = minimalPoly;
            this.factory = minimalPoly.Clone();
            this.inverseMod = UnivariateDivision.FastDivisionPreConditioning(minimalPoly);
            this.cardinality = minimalPoly.CoefficientRingCardinality() == null ? null : BigIntegerUtil.Pow(minimalPoly.CoefficientRingCardinality(), minimalPoly.Degree());
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        public virtual bool IsInTheBaseField(E element)
        {
            return element.IsConstant();
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        public virtual E Generator()
        {
            return minimalPoly.CreateMonomial(1);
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        public virtual int Degree()
        {
            return minimalPoly.Degree();
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        public virtual E GetMinimalPolynomial()
        {
            return minimalPoly.Clone();
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        public virtual E GetMinimalPolynomialRef()
        {
            return minimalPoly;
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        public virtual E Norm(E element)
        {
            return UnivariateResultants.ResultantAsPoly(minimalPoly, element);
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
        /// element}
        /// </summary>
        public virtual E ConjugatesProduct(E element)
        {
            return DivideExact(Norm(element), element);
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
        /// element}
        /// </summary>
        /// <summary>
        /// Gives the trace of field extension element (it is always belongs to the base field)
        /// </summary>
        public virtual E Trace(E element)
        {
            E minimalPoly = MinimalPolynomial(element);
            return Negate(DivideExact(minimalPoly.GetAsPoly(minimalPoly.Degree() - 1), minimalPoly.LcAsPoly()));
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
        /// element}
        /// </summary>
        /// <summary>
        /// Gives the trace of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the norm of univariate polynomial over this field extension, which is always a polynomial with the
        /// coefficients from the base field
        /// </summary>
        public virtual E NormOfPolynomial(UnivariatePolynomial<E> poly)
        {
            if (!poly.ring.Equals(this))
                throw new ArgumentException();
            if (minimalPoly is UnivariatePolynomial)
                return (E)NormOfPolynomialE((SimpleFieldExtension)this, (UnivariatePolynomial)poly);
            if (minimalPoly is UnivariatePolynomialZp64)
                return (E)NormOfPolynomialZp64((SimpleFieldExtension)this, (UnivariatePolynomial)poly);
            throw new Exception();
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
        /// element}
        /// </summary>
        /// <summary>
        /// Gives the trace of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the norm of univariate polynomial over this field extension, which is always a polynomial with the
        /// coefficients from the base field
        /// </summary>
        private static UnivariatePolynomial<E> NormOfPolynomialE<E>(SimpleFieldExtension<UnivariatePolynomial<E>> ring, UnivariatePolynomial<UnivariatePolynomial<E>> poly)
        {
            return MultivariateResultants.Resultant(ring.minimalPoly.AsMultivariate(MonomialOrder.DEFAULT).SetNVariables(2), MultivariatePolynomial.AsNormalMultivariate(poly.AsMultivariate(), 0), 0).AsUnivariate();
        }

        /// <summary>
        /// Minimal polynomial
        /// </summary>
        /// <summary>
        /// Factory polynomial
        /// </summary>
        /// <summary>
        /// Precomputed inverses for fast division
        /// </summary>
        /// <summary>
        /// Ring cardinality
        /// </summary>
        /// <summary>
        /// Constructs a simple field extension {@code F(α)} generated by the algebraic number {@code α} with the specified
        /// minimal polynomial.
        /// 
        /// <p><b>NOTE:</b> irreducibility test for the minimal polynomial is not performed here, use {@link
        /// IrreduciblePolynomials#irreducibleQ(IUnivariatePolynomial)} to test irreducibility.
        /// </summary>
        /// <param name="minimalPoly">the minimal polynomial</param>
        /// <summary>
        /// Returns whether the given element belongs to the base field
        /// </summary>
        /// <summary>
        /// Returns the generator element {@code α} of this field extension {@code F(α)}
        /// </summary>
        /// <summary>
        /// Returns the degree of this filed extension (that is the degree of minimal polynomial)
        /// </summary>
        /// <summary>
        /// Returns the minimal polynomial of the generator (that is the "modulo" polynomial {@code p(x)} of this field
        /// viewed as quotient field {@code F[x]/<p(x)>})
        /// </summary>
        /// <summary>
        /// INTERNAL *
        /// </summary>
        /// <summary>
        /// Gives the norm of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the product of all conjugates of given element (except element itself), that is {@code norm(element) /
        /// element}
        /// </summary>
        /// <summary>
        /// Gives the trace of field extension element (it is always belongs to the base field)
        /// </summary>
        /// <summary>
        /// Gives the norm of univariate polynomial over this field extension, which is always a polynomial with the
        /// coefficients from the base field
        /// </summary>
        // to bivariate
        private static UnivariatePolynomialZp64 NormOfPolynomialZp64(SimpleFieldExtension<UnivariatePolynomialZp64> ring, UnivariatePolynomial<UnivariatePolynomialZp64> poly)
        {
            return MultivariateResultants.Resultant(ring.minimalPoly.AsMultivariate(MonomialOrder.DEFAULT).SetNVariables(2), MultivariatePolynomialZp64.AsNormalMultivariate(poly.AsMultivariate(), 0), 0).AsUnivariate();
        }

        /// <summary>
        /// Gives the norm of multivariate polynomial over this field extension, which is always a polynomial with the
        /// coefficients from the base field.
        /// </summary>
        public virtual MPoly NormOfPolynomial<MPoly extends AMultivariatePolynomial>(MultivariatePolynomial<E> poly)
        {
            if (!poly.ring.Equals(this))
                throw new ArgumentException();
            if (minimalPoly is UnivariatePolynomial)
                return (MPoly)NormOfPolynomialE((SimpleFieldExtension)this, (MultivariatePolynomial)poly);
            if (minimalPoly is UnivariatePolynomialZp64)
                return (MPoly)NormOfPolynomialZp64((SimpleFieldExtension)this, (MultivariatePolynomial)poly);
            throw new Exception();
        }

        /// <summary>
        /// Gives the norm of multivariate polynomial over this field extension, which is always a polynomial with the
        /// coefficients from the base field.
        /// </summary>
        private static MultivariatePolynomial<E> NormOfPolynomialE<E>(SimpleFieldExtension<UnivariatePolynomial<E>> ring, MultivariatePolynomial<UnivariatePolynomial<E>> poly)
        {
            return MultivariateResultants.Resultant(ring.minimalPoly.AsMultivariate(MonomialOrder.DEFAULT).SetNVariables(poly.nVariables + 1), MultivariatePolynomial.AsNormalMultivariate(poly, 0), 0).DropVariable(0);
        }

      
        private static MultivariatePolynomialZp64 NormOfPolynomialZp64(SimpleFieldExtension<UnivariatePolynomialZp64> ring, MultivariatePolynomial<UnivariatePolynomialZp64> poly)
        {
            return MultivariateResultants.Resultant(ring.minimalPoly.AsMultivariate(MonomialOrder.DEFAULT).SetNVariables(poly.nVariables + 1), MultivariatePolynomialZp64.AsNormalMultivariate(poly, 0), 0).DropVariable(0);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        public virtual E MinimalPolynomial(E element)
        {

            //if (element.equals(getOne()))
            //    return getMinimalPolynomial();
            UnivariatePolynomial<E> es = UnivariatePolynomial.Create(this, CreateArray(Negate(element), GetOne()));
            return UnivariateSquareFreeFactorization.SquareFreePart(NormOfPolynomial(es));
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public virtual MultipleFieldExtension<Term, mPoly, E> AsMultipleExtension<Term extends AMonomial<Term>, mPoly extends AMultivariatePolynomial<Term, mPoly>>()
        {
            return MultipleFieldExtension.MkMultipleExtension(this);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public override int NVariables()
        {
            return 1;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public override E Factory()
        {
            return factory;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public override bool IsEuclideanRing()
        {
            return minimalPoly.IsOverField();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public override BigInteger Cardinality()
        {
            return cardinality;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        public override BigInteger Characteristic()
        {
            return minimalPoly.CoefficientRingCharacteristic();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        protected virtual bool ShouldReduceFast(int dividendDegree)
        {
            int mDeg = minimalPoly.Degree();
            if (dividendDegree < mDeg)
                return false;
            if (IsFiniteField())
            {
                if (mDeg < 8)
                    return false;
                int defect = dividendDegree / mDeg;
                if (mDeg <= 20)
                    return defect <= 16;
                else
                    return defect <= 30;
            }
            else
                return false;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Add(E a, E b)
        {
            return ShouldReduceFast(Math.Max(a.Degree(), b.Degree())) ? PolyAddMod(a, b, minimalPoly, inverseMod, true) : PolyAddMod(a, b, minimalPoly, true);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Subtract(E a, E b)
        {
            return ShouldReduceFast(Math.Max(a.Degree(), b.Degree())) ? PolySubtractMod(a, b, minimalPoly, inverseMod, true) : PolySubtractMod(a, b, minimalPoly, true);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Multiply(E a, E b)
        {
            return ShouldReduceFast(a.Degree() + b.Degree()) ? PolyMultiplyMod(a, b, minimalPoly, inverseMod, true) : PolyMultiplyMod(a, b, minimalPoly, true);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Negate(E element)
        {
            return ShouldReduceFast(element.Degree()) ? PolyNegateMod(element, minimalPoly, inverseMod, true) : PolyNegateMod(element, minimalPoly, true);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E AddMutable(E a, E b)
        {
            return ShouldReduceFast(Math.Max(a.Degree(), b.Degree())) ? PolyAddMod(a, b, minimalPoly, inverseMod, false) : PolyAddMod(a, b, minimalPoly, false);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E SubtractMutable(E a, E b)
        {
            return ShouldReduceFast(Math.Max(a.Degree(), b.Degree())) ? PolySubtractMod(a, b, minimalPoly, inverseMod, false) : PolySubtractMod(a, b, minimalPoly, false);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E MultiplyMutable(E a, E b)
        {
            return ShouldReduceFast(a.Degree() + b.Degree()) ? PolyMultiplyMod(a, b, minimalPoly, inverseMod, false) : PolyMultiplyMod(a, b, minimalPoly, false);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E NegateMutable(E element)
        {
            return ShouldReduceFast(element.Degree()) ? PolyNegateMod(element, minimalPoly, inverseMod, false) : PolyNegateMod(element, minimalPoly, false);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Reciprocal(E element)
        {
            if (element.IsZero())
                throw new ArithmeticException("divide by zero");
            if (IsOne(element))
                return element;
            if (IsMinusOne(element))
                return element;
            E[] xgcd = UnivariateGCD.PolynomialFirstBezoutCoefficient(element, minimalPoly);
            return xgcd[1].DivideByLC(xgcd[0]);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override FactorDecomposition<E> Factor(E element)
        {
            return FactorDecomposition.Unit(this, element);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E GetZero()
        {
            return minimalPoly.CreateZero();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E GetOne()
        {
            return minimalPoly.CreateOne();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override bool IsZero(E element)
        {
            return element.IsZero();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override bool IsOne(E element)
        {
            return element.IsOne();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E ValueOf(long val)
        {
            return GetOne().Multiply(val);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E ValueOfBigInteger(BigInteger val)
        {
            return GetOne().MultiplyByBigInteger(val);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E ValueOf(E val)
        {
            return ShouldReduceFast(val.Degree()) ? PolyMod(val.SetCoefficientRingFrom(factory), minimalPoly, inverseMod, false) : PolyMod(val.SetCoefficientRingFrom(factory), minimalPoly, false);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Copy(E element)
        {
            return element.Clone();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E[] CreateArray(int length)
        {
            return minimalPoly.CreateArray(length);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E[][] CreateArray2d(int length)
        {
            E[] array = CreateArray(0);
            return (E[][])Array.NewInstance(array.GetType(), length);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E[][] CreateArray2d(int m, int n)
        {
            E[, ] arr = CreateArray2d(m);
            for (int i = 0; i < arr.Length; i++)
                arr[i] = CreateArray(n);
            return arr;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override int Compare(E o1, E o2)
        {
            return o1.CompareTo(o2);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E RandomElement(RandomGenerator rnd)
        {
            E r = RandomUnivariatePolynomials.RandomPoly(minimalPoly, rnd.NextInt(minimalPoly.Degree()), rnd);
            if (r.IsOverFiniteField())
            {
                if (r is UnivariatePolynomial)
                    ((UnivariatePolynomial)r).Multiply(((UnivariatePolynomial)r).ring.RandomElement(rnd));
                else
                    r.Multiply(rnd.NextLong());
            }

            return r;
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Variable(int variable)
        {
            if (variable != 0)
                throw new ArgumentException();
            return ValueOf(minimalPoly.CreateMonomial(1));
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override E Parse(string @string)
        {
            return ValueOf(factory.ParsePoly(@string));
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override bool Equals(object o)
        {
            if (this == o)
                return true;
            if (o == null || GetType() != o.GetType())
                return false;
            SimpleFieldExtension<TWildcardTodo> that = (SimpleFieldExtension<TWildcardTodo>)o;
            return minimalPoly.Equals(that.minimalPoly);
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override int GetHashCode()
        {
            return minimalPoly.GetHashCode();
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override string ToString(IStringifier<E> stringifier)
        {
            string cfrStr = factory.CoefficientRingToString(stringifier);
            string varStr = stringifier.GetBinding(factory.CreateMonomial(1), IStringifier.DefaultVar());
            string irrStr = minimalPoly.ToString(stringifier);
            return "(" + cfrStr + ")[" + varStr + "]/<" + irrStr + ">";
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public virtual string ToString(params string[] variables)
        {
            return ToString(IStringifier.MkPolyStringifier(factory, variables));
        }

      
        /// <summary>
        /// Computes minimal polynomial of a given algebraic element
        /// </summary>
        //if (element.equals(getOne()))
        //    return getMinimalPolynomial();
        /// <summary>
        /// Returns a view of this as a multiple field extension
        /// </summary>
        /// <summary>
        /// empiric to switch between fast and plain division
        /// </summary>
        public override string ToString()
        {
            return ToString(IStringifier.DefaultVars(1));
        }
    }
}